# 学习`8x8`点阵屏_静态

点阵屏本身似乎不用多说，只是把64个发光二极管连一块了，阳极接高电平，阴极接低电平就能点亮。关键是如何去管理这64个发光二极管。

# 主过程

![image-20240715162836082](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407151628176.png)

从图 7-2 上可以看出，其实点阵 LED 点亮原理还是很简单的。在图中大方框外侧的就是点阵 LED 的引脚号，左侧的 8 个引脚是接的内部 LED 的阳极，上侧的 8 个引脚接的是内部LED 的阴极。那么如果我们把 9 脚置成高电平、 13 脚置成低电平的话，左上角的那个 LED
小灯就会亮了。  

当然，我们的目的肯定不是就点亮一颗灯珠，我们要显示字符的，比如这样：

![1721030885934](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407151609814.jpg)

那这具体逻辑是什么呢？首先我们要清楚的是这个字符能直接显示吗？当然是不行的，点阵屏本身的硬件电路就做不到这一点呀，每次只能对某一行或者某一列进行操作，就拿上面的图来说，规定从上到下行数依次增大，那么如果我要同时对第二行和第三行操作该怎么办呢？为了让第二行和第三行有点亮的可能，要先对左边的那些引脚进行操作，要把14,8这两个引脚置为高电平，试想一下，如果14,8置为低电平，那就意味着这两行的发光二极管的阳极接的都是低电平，那无论阴极是高电平还是低电平，LED都不亮呀。好，对行操作过后就要对列进行操作了，现在为了点亮第二行的第一个（从左往右数）LED，我要把13号引脚置为低电平，这样第二行第一个LED就被点亮了，但此时8号引脚也是高电平，于是在点亮第二行第一个LED的同时，不可避免的会把第三行第一个LED也点亮，还好，第三行第一个LED本来就是要亮的，但当我们点亮第二行第二个LED的同时，同理第二行第三个LED也会被点亮，而且是无法被避免地点亮，所以我们做不到同时点亮整个字符，只能逐行逐行地点亮。但为什么看起来整个字符都亮着的呢？

这是因为人眼是存在BUG的，人眼的视觉系统可以感知的最低刷新频率约为`24Hz`。低于这个频率,人眼会感受到明显的闪烁现象,也就是说，当闪烁光源的时间间隔小于42毫秒时,人眼就无法感知到间歇性的闪烁,而是感受到一个持续亮着的光源。我定时的间隔是`2ms`，这意味着，每过`2ms`点阵屏都会换一行亮。这里的点阵屏共有八行，从第一行第一次刚开始亮到第一行第二次亮，中间隔了`16ms`，低于42毫秒，所以人眼就认为第一行一直在亮，同样的，人眼也认为其它行也一直在亮，于是就认为整个字符都在亮了。

到时候，我们可以用一些取模软件去取列的字形码，放在数组里；由于是逐行点亮，所以行最初的字形码就是1000 0000，第一行电平是1，就可以对第一行进行操作，其它行是0，操作第一行的时候就不会影响其它行。等第一行点亮之后，就用循环移位把行字形码变成0100 0000 ，再访问第数组中二个元素，得到新的列字形码，依次类推就行。

现在就是把字形码送进去了，怎么送呢？之前我们几乎都是并行输数据，比如要点亮第一个LED，一看原理图，LED阳极已经接在`VCC`上了，阴极则接在`P1^0`到`P1^7`这八个IO口上，那就直接让`P1`= `0xfe`；一次性输八位，可单片机就那几个IO口，`8x8`点阵屏有16个接口，总不能直接连在IO口上吧，要真是这样，效率可就太低了。于是就要用到一个名为`74HC595`的芯片来节约IO口。

# `74HC595`

我并不是很了解`74HC595`，这里只是略微说一下，我们只操作它的三个接口，其它都默认，这三个接口分别是

- 用来串行输入数据的数据输入口，引脚号是`14脚：DS（SER）`;
- 用来区别数据有效性的接口，引脚号是`11脚：SCK（SHCP）`;
- 用来把存储的数据输出的触发口，引脚号是`12脚：RCK（STCP）`;

![image-20240718085641093](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407180856251.png)

使用时，先往数据输入口里输入1或者0，在输入一个比特位后，为了确定这个比特位确实是有效的，而不是因其它因素而产生的无效比特位，就需要给11脚一个上升沿，上升沿是个过程，是从低电平上升到高电平的过程，所以要先把对应的接口置为0，需要上升沿时，就把接口置为1，就有了电平上升的过程，之后再把对应接口置为0，为下一次上升沿做准备；`74HC595`的11脚收到上升沿之后，就知道刚刚输入的数据确实是有效的，就会把这个比特位通过移位的方式存储起来，怎么个存储法呢？`74HC595`里有一个八比特位的移位寄存器，在刚接通电源的时候，这个移位寄存器中存储着八比特位全为1或者0的数据，比如00000000，在确认输入数据是有效的之后，移位寄存器就会把内部存储的数据向高位方向移动一位，然后把之前输入的数据存在空出来的最低位；原来最高位的数据跑哪去了呢？如过它没有级联（就是再连一个`74HC595`），那这位数据就丢失了，如果有级联，那这位数据就会跑到下一级移位寄存器的最低位，然后下一级移位寄存器再重复