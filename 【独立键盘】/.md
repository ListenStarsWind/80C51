# 备注

这个文档可不是DEBUG文档，而是备注文档。本文档主要用于极其粗略地说明独立按键的工作原理。

![image-20240630152458815](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE.png)

上面是独立按键的构造图。

![image-20240630152700255](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E5%8E%9F%E7%90%86%E5%9B%BE.png)

上面是独立按键的原理图，独立按键就连接在管脚上。最左边的是口线寄存器，在此种情况下，只需要知道它输出高电平；非门将高电平反向成低电平，与场效应管的栅极相连接；而场效应管的源极又接地，所以场效应管不导通。在按键不被按下的情况下，场效应管的漏极既不与栅极源极导通（场效应管是关闭的），又不与独立按键的GND连接（没按下），至于那个“输入数据”，只是发挥一个读取电位的功能，这就意味着漏极是一个悬空的状态，而漏极又通过上拉电阻与VCC相连，漏极又是悬空的，所以没有电流流过，没电位流过，那从VCC到漏极其电势都是相等的，这样“输入数据”就检测到了一个高电平；当按钮按下后，VCC就相当于中间隔着一个上拉电阻与GND相连，这样就形成回路了，由于这个上拉电阻的阻值很大，就会分担绝大多数的电压，漏极就会检测到低电平。



这里还有一个按键消抖需要讲。当按下或释放按键时，按键的接触点会在短时间内多次接触和分离，导致电平在高低之间快速切换。这种抖动时间通常在几毫秒到几十毫秒之间。由于电平信号并不稳定，所以电路系统就会误判按键状态。为了解决这个问题，可以从硬件和软件两个方向下功夫。

- 硬件

  1. 在按键与GND之间连接一个电容，并在按键与电位检测点之间连接一个电阻，从而实现RC低波滤通电路，具体原理我也不知道
  2. 使用施密特触发器，这个我更不知道。

- 软件

  1. 既然按键状态改变时的电平信号不稳定，那我就干脆不检测。一旦我检测到电平信号发生改变，那就先等一会，即延迟一会，再检测，如果过一会检测到的电平信号和刚开始的电平信号一致，那就承认此次的按键状态改变有效。那到底多长时间才算“一会”呢？这取决于两个方面：

  - 按键抖动的持续时间，一遍情况下，是几毫秒到几十毫秒
  - 系统的响应时间，通俗的说，类似于鼠标点击到电脑有反应的那段时间
    - 通常，延迟时间设置在10毫秒到50毫秒之间是比较常见的选择。具体的延迟时间可以根据实际情况进行调整。

  2. 连续多次读取按键状态，如果在一段时间内按键状态一致，则认为按键状态有效。

对于我们来说，当然用的是软件消抖，毕竟单片机上没有消抖硬件呀。



上面的是根据《清翔0基础教你学单片机》的教程撰写的开发说明，为方便叙述，下文将《清翔0基础教你学单片机》简称为清翔。

不过我个人认为《手把手教你学习单片机》的教程更好，为方便描述，下文将《手把手教你学习单片机》简称为雪松。

如下：

![image-20240711174030529](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407111740632.png)

常用的按键电路有两种形式:独立式按键和矩阵式按键。独立式按键比较简单,它们各自与独立的输人线相连接,如图所示。

4条输人线接到单片机的I/〇口上,当按下按键`K1`时,`+5V` 依次通过电阻 `R1`	 和按键`K1	`最终进人 `GND`形成一条通路,这条线路的全部电压都加到电阻`R1`上,引脚 `KeyIn1` 就是一个低电平。当松开按键后,线路断开,不会有电流通过,`KeyIn1	`和`+5V`应该是等电位,是一个高电平。因此,可以通过引脚`KeyIn1`这个I/O口的高低电平来判断是否有按键按下。

首先说明一点,就是现在绝大多数单片机的l/0口都是使用MOS管而非三极管,但在这里的 MOS管,其原理和三极管是一样的,因此用三极管替代它来进行原理讲解,把前面讲过的三极管的知识搬过来,一切都是适用的,有助于理解。

方框内的电路都是指单片机内部部分,方框外的就是外接的上拉电阻和按键，这个地方大家要注意一下,就是当要读取外部按键信号的时候,单片机必须先给该引脚写“1”,也就是高电平,这样才能正确读取到外部按键信号,下面来分析一下缘由。

当内部输出是高电平时,经过一个反向器变成低电平,`NPN`三极管不会导通,单片机I/O口从内部来看,由于上拉电阻R的存在,所以是一个高电平。当外部没有按键按下将电平拉低,`VCC`也是`+5V	`,它们之间虽然有两个电阻,但是没有压差,就不会有电流,线上所有的位置都是高电平,这时就可以正常读取按键的状态了。

当内部输出是低电平时,经过一个反相器变成高电平,`NPN`三极管导通,单片机的内部I/〇口就是一个低电平,这时,外部虽然也有上拉电阻的存在,但是两个电阻是并联关系,不管按键是否按下,单片机的I/〇口上输人单片机内部的状态都是低电平,因此无法正常读取按键的状态。

这与水流很类似,内部和外部,只要有一边是低电位,电流就会顺流而下,由于只有上拉电阻,下边没有分压电阻,直接到`	GND`上,所以不管另一边是高电位还是低电位,电平都是低电平。
从上面的分析可以得出一个结论,这种具有上拉的准双向l/0口,如果要正常读取外部信号的状态,必须首先保证自己内部输出的是1,如果内部输出0,则无论外部信号是1还是0,这个引脚读进来的都是0。



上面是雪松的原文，依据这种说法，不管是清翔还是雪松的程序似乎都存在一些危险性：在进入按键检测之前，没有把对应的IO口手动置为1，万一前面的操作把IO口置为0了呢？

就此问题，我询问了Monica：

![image-20240713092308912](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407130923116.png)

![image-20240713092336061](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407130923268.png)

噢，雪松的`8.4.3`节命名似乎是有问题的，小节名为独立按键的扫描，可我实际看了一下，下面的程序实际上用的是矩阵键盘。弄得我最开始看时宕机了，它把相关IO口置为了0，我想不应该置为1吗，又看了一会，才意识到，这用的是矩阵键盘，这里的置为0是创造`GND`用的，和我上面说的相关IO口不是一个东西

另外，雪松对于按键检测的具体动作与清翔是有区别的，清翔是检测一个固定的电平值，而雪松则建议检测电平值的变化，`8.4.3`的第一个例程用的不明显，你可以看看第二个例程，用的就非常明显了。

我们将在`prefer.c`中建立多个独立的程序，程序的具体选择将由条件编译来实现。

# `CODE`1

功能描述：复位后，数码管最高位显示数字0，按下`S2`，数字加一；若数字超过一位，自动清0。

本程序的目的是引出按键消抖现象，所以不会考虑按键抖动现象。还有，这个程序是我第一次使用bit类型。

<video src="https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407131040637.mp4"></video>

可以看到，显示效果很好，同时也可以看到，有时明明只按了一次按键，数字却不止加了一次。这是由于按键抖动造成的。

## 按键抖动

通常按键所用的开关都是机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上就稳定的接通，在断开时也不会一下子彻底断开，而是在闭合和断开的瞬间伴随了一连串的抖动，如图 8-10 所示。  

![image-20240713110308596](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407131103800.png)

按键稳定闭合时间长短是由操作人员决定的，通常都会在 `100ms` 以上，刻意快速按的话能达到 `40-50ms` 左右，很难再低了。抖动时间是由按键的机械特性决定的，一般都会在` 10ms`以内，为了确保程序对按键的一次闭合或者一次断开只响应一次，必须进行按键的消抖处理。当检测到按键状态变化时，不是立即去响应动作，而是先等待闭合或断开稳定后再进行处理。按键消抖可分为硬件消抖和软件消抖。

硬件消抖就是在按键上并联一个电容，如图 8-11 所示，利用电容的充放电特性来对抖动过程中产生的电压毛刺进行平滑处理，从而实现消抖。但实际应用中，这种方式的效果往往不是很好，而且还增加了成本和电路复杂度，所以实际中使用的并不多。

![image-20240713110909362](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407131109426.png)  

在绝大多数情况下，我们是用软件即程序来实现消抖的。最简单的消抖原理，就是当检测到按键状态变化后，先等待一个 `10ms` 左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才检测到的状态相同，就可以确认按键已经稳定的动作了。  

怎么延迟呢？分为两种，创建特定的延迟函数，用不断循环的方式让去耗时间。据说`GTA5`之前有段代码硬是把`if`循环了19.8亿次，搞得每次开线上模式都要好久，后来有个黑客大哥用逆向工具把这段代码挖出来了，做成帖子发了出来，让`R星`不得不修这个BUG，真就游戏优化直接从社区里长出来。

![1720841178622](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407131126523.jpg)

原神也是，`PV`可以从玩家群体里自己长出来。哈哈。

不过这种方式一般只在演示程序里出现，在实际做项目开发的时候，程序量往往很大，各种状态值也很多， while(1)这个主循环要不停的扫描各种状态值是否有发生变化，及时的进行任务调度，如果程序中间加了这种 delay 延时操作后，很可能某一事件发生了，但是我们程序还在进行 delay 延时操作中，当这个事件发生完了，程序还在 delay 操作中，当我们 delay 完事再去检查的时候，已经晚了，已经检测不到那个事件了。  

你可以去看本项目文件夹下的DEBUG文件夹，里面也有一个`.md`文档，里面描述的BUG就是这个原因。

![image-20240713113711289](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407131137641.png)

为了避免这种情况的发生，我们要尽量缩短 while(1)循环一次所用的时间，而需要进行长时间延时的操作，必须想其它的办法来处理。  

那么消抖操作所需要的延时该怎么处理呢？其实除了这种简单的延时，我们还有更优异的方法来处理按键抖动问题。举个例子：我们启用一个定时中断，每 `2ms` 进一次中断，扫描一次按键状态并且存储起来，连续扫描 8 次后，看看这连续 8 次的按键状态是否是一致的。
8 次按键的时间大概是 `16ms`，这` 16ms` 内如果按键状态一直保持一致，那就可以确定现在按键处于稳定的阶段，而非处于抖动的阶段，如图 8-12。  

![image-20240713114057576](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407131140640.png)

假如左边时间是起始 0 时刻，每经过` 2ms`左移一次，每移动一次，判断当前连续的 8 次  按键状态是不是全 1 或者全 0，如果是全 1 则判定为弹起，如果是全 0 则判定为按下，如果0 和 1 交错，就认为是抖动，不做任何判定。想一下，这样是不是比简单的延时更加可靠？  

利用这种方法，就可以避免通过延时消抖占用单片机执行时间，而是转化成了一种按键状态判定而非按键过程判定，我们只对当前按键的连续 `16ms` 的 8 次状态进行判断，而不再关心它在这 `16ms `内都做了什么事情，那么下面就按照这种思路用程序实现出来。

# `CODE2`

  <video src="https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202407131253558.mp4"></video>

还是有些问题的，6的时候按了4次没有反应。
