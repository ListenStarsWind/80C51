# DEBUG

很不幸，该附属项目又启动了。



主项目功能描述：开启单片机，数码管显示数字00065534,；按下S2，数码管显示数字减一；按下S3，数码管显示数字加一。

实际现象：数码管可以正常显示数字00065534，但按下S2或者S3后，显示数字并不发生改变。

项目初始原码：

```c
#include<reg52.h>
#include<intrins.h>

typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned long ulint;

sbit Key2 = P3^0;
sbit Key3 = P3^1;
sbit Key4 = P3^2;
sbit Key5 = P3^3;

sbit DU = P2^6;
sbit WE = P2^7;

uchar Data[] = {
                    0x3F,0x06,0x5B,0x4f,0x66,
                    0x6D,0x7D,0x07,0x7F,0x6F, 
                    0x77,0x7C,0x39,0x5E,0x79,  
                    0x71,0x76,0x38,0x40,0x00 
                };

typedef enum sequence
{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
    Sixth,
    Seventh,
    Eighth   
}sequence;

void delay(uint span)
{
    uint i = 0;
    uint j = 0;
    for(i=0;i<span;i++)
    {
        for(j=0;j<144;j++);
    }
}

void SegmentDisplayInit(void)
{
    P0 = 0xff;
    WE = 1;
    WE = 0;
}

#define DELAY//打开使用延迟法判断按键状态，关闭使用计数法判断按键状态

#ifdef DELAY

void iskey(ulint* num)
{
    if(Key2 == 0)
    {
        delay(20);
        if(Key2 == 0)
        {
            (*num)--;
            while(Key2 == 0);
        }
    }
    if(Key3 == 0)
    {
        delay(20);
        if(Key3 == 0)
        {
            (*num)++;
            while(Key3 == 0);
        }
    }
}

#else

void iskey(ulint* num)
{
    uchar count = 0x00;
    while(count < 0x05)
    {
        if(Key2 == 0)
        {
            count++;
        }
        else
        {
            count = 0;
        }
        delay(1);
    }
    if(count == 0x05)
    {
        (*num)++;
    }

    count = 0x00;
    while(count < 0x05)
    {
        if(Key3 == 0)
        {
            count++;
        }
        else
        {
            count = 0;
        }
        delay(1);
    }
    if(count == 0x05)
    {
        (*num)--;
    }
}

#endif

uchar digit(ulint* value)
{
    uchar ret = 0;
    ret = *value % 10 + 48;
    *value = *value / 10;
    return ret;
}

void stdout(uint value,sequence serial)
{
    uchar position = 0xfe;
    P0 = 0x00;
    DU = 1;
    DU = 0;
    P0 = _crol_(position,(uint)serial);
    WE = 1;
    WE = 0;
    P0 = Data[value];
    DU = 1;
    DU = 0;
}

void Display(ulint number)
{
    uint eighth = (uint)(digit(&number) - '0');
    uint seventh = (uint)(digit(&number) - '0');
    uint sixth = (uint)(digit(&number) - '0');
    uint fifth = (uint)(digit(&number) - '0');
    uint fourth = (uint)(digit(&number) - '0');
    uint third = (uint)(digit(&number) - '0');
    uint second = (uint)(digit(&number) - '0');
    uint first = (uint)(digit(&number) - '0');  
    uchar i = 0;
    uchar j = 0;
    for(i=0;i<3000;i++)
    {
        for(j=0;j<144;j++)
        {
                stdout(first,First);
                stdout(second,Second);
                stdout(third,Third);
                stdout(fourth,Fourth);
                stdout(fifth,Fifth);
                stdout(sixth,Sixth);
                stdout(seventh,Seventh);
                stdout(eighth,Eighth);
        }
    }
}

void main()
{
    ulint number = 65534;
    SegmentDisplayInit();
    while(1)
    {
        iskey(&number);
        Display(number);
    }
}
```

现象演示：

<video src="https://md-wind.oss-cn-nanjing.aliyuncs.com/md/%E5%88%9D%E5%A7%8B%E7%8E%B0%E8%B1%A1%E6%BC%94%E7%A4%BA.mp4"></video>

由于显示函数已经经过了很多测试，所以这次DEBUG主要集中于独立按键本身，我打算对iskey函数进行特别调试，Key2 and Key3将通过终端进行数据输入。

不对呀，Keil调试起来是可以让数字变化的，怎么实际烧录到板子上没反应。

<video src = "https://md-wind.oss-cn-nanjing.aliyuncs.com/md/%E8%B0%83%E8%AF%95%E5%B1%95%E7%A4%BA.mp4" ></video>

下边是宏观上看：

<video src = "https://md-wind.oss-cn-nanjing.aliyuncs.com/md/%E5%AE%8F%E8%A7%82%E8%B0%83%E8%AF%95.mp4" ><\video>

硬件问题也核实过了，清翔的配套独立按键程序是可以正常运行的，按下按键是有正常反应的，难道问题在显示函数上？

在线仿真，启动！

不对呀，在线仿真改不了端口电平，那我怎么模拟按键按下？

